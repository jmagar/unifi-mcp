"""
Monitoring and statistics MCP resources for UniFi MCP Server.

Provides structured access to events, alarms, statistics, and system information.
"""

import logging
from fastmcp import FastMCP

from ..client import UnifiControllerClient
from ..formatters import format_timestamp, format_data_values

logger = logging.getLogger(__name__)


def register_monitoring_resources(mcp: FastMCP, client: UnifiControllerClient) -> None:
    """Register all monitoring and statistics MCP resources."""
    
    @mcp.resource("unifi://events")
    async def resource_events():
        """Get recent events with clean formatting (default site)."""
        try:
            events = await client.get_events("default", 100)
            
            if isinstance(events, dict) and "error" in events:
                return f"Error retrieving events: {events['error']}"
            
            if not isinstance(events, list):
                return "Error: Unexpected response format"
            
            if not events:
                return "**UniFi Events**\n\nNo recent events found."
            
            # Format recent events with timestamps and messages
            recent_events = events[-15:]
            event_texts = []
            for event in recent_events:
                time_str = format_timestamp(event.get("time", 0))
                key = event.get("key", "Unknown")
                msg = event.get("msg", "No message")
                user = event.get("user", "System")
                event_texts.append(f"{time_str}: {key} - {msg} ({user})")
            return f"Recent Events ({len(recent_events)} total): " + " | ".join(event_texts)
            
        except Exception as e:
            logger.error(f"Error in events resource: {e}")
            return f"Error retrieving events: {str(e)}"
    
    
    @mcp.resource("unifi://events/{site_name}")
    async def resource_site_events(site_name: str):
        """Get recent events with clean formatting for specific site."""
        try:
            events = await client.get_events(site_name, 100)
            
            if isinstance(events, dict) and "error" in events:
                return f"Error retrieving events for site {site_name}: {events['error']}"
            
            if not isinstance(events, list):
                return "Error: Unexpected response format"
            
            if not events:
                return f"**UniFi Events - {site_name}**\n\nNo recent events found."
            
            return format_generic_list(events[-15:], "Recent Events", ["time", "key", "msg", "user"])
            
        except Exception as e:
            logger.error(f"Error in site events resource for {site_name}: {e}")
            return f"Error retrieving events for site {site_name}: {str(e)}"
    
    
    @mcp.resource("unifi://alarms")
    async def resource_alarms():
        """Get active alarms with clean formatting (default site)."""
        try:
            alarms = await client.get_alarms("default")
            
            if isinstance(alarms, dict) and "error" in alarms:
                return f"Error retrieving alarms: {alarms['error']}"
            
            if not isinstance(alarms, list):
                return "Error: Unexpected response format"
            
            # Filter active alarms only
            active_alarms = [alarm for alarm in alarms if not alarm.get("archived", False)]
            
            return format_generic_list(active_alarms[:10], "Active Alarms", ["time", "key", "msg", "catname"])
            
        except Exception as e:
            logger.error(f"Error in alarms resource: {e}")
            return f"Error retrieving alarms: {str(e)}"
    
    
    @mcp.resource("unifi://alarms/{site_name}")
    async def resource_site_alarms(site_name: str):
        """Get active alarms with clean formatting for specific site."""
        try:
            alarms = await client.get_alarms(site_name)
            
            if isinstance(alarms, dict) and "error" in alarms:
                return f"Error retrieving alarms for site {site_name}: {alarms['error']}"
            
            if not isinstance(alarms, list):
                return "Error: Unexpected response format"
            
            # Filter active alarms only
            active_alarms = [alarm for alarm in alarms if not alarm.get("archived", False)]
            
            if not active_alarms:
                return f"**UniFi Active Alarms - {site_name}**\n\nüòä No active alarms - all clear!"
            
            summary = f"**UniFi Active Alarms - {site_name}** ({len(active_alarms)} active)\n\n"
            
            # Limit to 10 most recent alarms
            for alarm in active_alarms[:10]:
                timestamp = format_timestamp(alarm.get("time", 0))
                alarm_type = alarm.get("key", "Unknown")
                message = alarm.get("msg", "No message")
                severity = alarm.get("catname", "Unknown")
                device = alarm.get("ap", alarm.get("gw", alarm.get("sw", "Unknown")))
                handled = alarm.get("handled", False)
                
                # Determine alarm icon based on severity
                if severity.lower() in ["critical", "high"]:
                    icon = "üö®"
                elif severity.lower() in ["medium", "warning"]:
                    icon = "‚ö†Ô∏è"
                elif severity.lower() in ["low", "info"]:
                    icon = "‚ÑπÔ∏è"
                else:
                    icon = "üö®"
                
                summary += f"{icon} **{alarm_type}** ({severity})\n"
                summary += f"  ‚Ä¢ Time: {timestamp}\n"
                summary += f"  ‚Ä¢ Device: {device}\n"
                summary += f"  ‚Ä¢ Message: {message}\n"
                if handled:
                    summary += "  ‚Ä¢ Status: ‚úÖ Handled\n"
                else:
                    summary += "  ‚Ä¢ Status: üî¥ Unhandled\n"
                summary += "\n"
            
            if len(active_alarms) > 10:
                summary += f"... and {len(active_alarms) - 10} more active alarms\n"
            
            return format_generic_list(active_alarms[:10], "Site Active Alarms", ["time", "key", "msg", "catname"])
            
        except Exception as e:
            logger.error(f"Error in site alarms resource for {site_name}: {e}")
            return f"Error retrieving alarms for site {site_name}: {str(e)}"
    
    
    @mcp.resource("unifi://health")
    async def resource_health():
        """Get site health status with clean formatting (default site)."""
        try:
            health = await client.get_site_health("default")
            
            if isinstance(health, dict) and "error" in health:
                return f"Error retrieving health status: {health['error']}"
            
            if not isinstance(health, list):
                return "Error: Unexpected response format"
            
            if not health:
                return "**UniFi Site Health**\n\nNo health data available."
            
            summary = "**UniFi Site Health Status**\n\n"
            
            for subsystem in health:
                subsystem_name = subsystem.get("subsystem", "Unknown")
                status = subsystem.get("status", "Unknown")
                num_ok = subsystem.get("num_adopted", 0)
                num_pending = subsystem.get("num_pending", 0)
                num_disconnected = subsystem.get("num_disconnected", 0)
                
                # Determine status icon
                if status.lower() == "ok":
                    icon = "‚úÖ"
                elif status.lower() == "warning":
                    icon = "‚ö†Ô∏è"
                elif status.lower() == "error":
                    icon = "‚ùå"
                else:
                    icon = "‚ùì"
                
                # Map subsystem names to friendly names
                if subsystem_name == "wlan":
                    friendly_name = "Wireless Networks"
                elif subsystem_name == "wan":
                    friendly_name = "Internet Connection"
                elif subsystem_name == "lan":
                    friendly_name = "Local Network"
                elif subsystem_name == "vpn":
                    friendly_name = "VPN Services"
                else:
                    friendly_name = subsystem_name.replace("_", "/").title()
                
                summary += f"{icon} **{friendly_name}**: {status.title()}\n"
                if num_ok > 0:
                    summary += f"  ‚Ä¢ Online: {num_ok}\n"
                if num_pending > 0:
                    summary += f"  ‚Ä¢ Pending: {num_pending}\n"
                if num_disconnected > 0:
                    summary += f"  ‚Ä¢ Disconnected: {num_disconnected}\n"
                summary += "\n"
            
            return format_generic_list(health, "Health Status", ["subsystem", "status"])
            
        except Exception as e:
            logger.error(f"Error in health resource: {e}")
            return f"Error retrieving health status: {str(e)}"
    
    
    @mcp.resource("unifi://health/{site_name}")
    async def resource_site_health(site_name: str):
        """Get site health status with clean formatting for specific site."""
        try:
            health = await client.get_site_health(site_name)
            
            if isinstance(health, dict) and "error" in health:
                return f"Error retrieving health status for site {site_name}: {health['error']}"
            
            if not isinstance(health, list):
                return "Error: Unexpected response format"
            
            if not health:
                return f"**UniFi Site Health - {site_name}**\n\nNo health data available."
            
            summary = f"**UniFi Site Health Status - {site_name}**\n\n"
            
            for subsystem in health:
                subsystem_name = subsystem.get("subsystem", "Unknown")
                status = subsystem.get("status", "Unknown")
                num_ok = subsystem.get("num_adopted", 0)
                num_pending = subsystem.get("num_pending", 0)
                num_disconnected = subsystem.get("num_disconnected", 0)
                
                # Determine status icon
                if status.lower() == "ok":
                    icon = "‚úÖ"
                elif status.lower() == "warning":
                    icon = "‚ö†Ô∏è"
                elif status.lower() == "error":
                    icon = "‚ùå"
                else:
                    icon = "‚ùì"
                
                # Map subsystem names to friendly names
                if subsystem_name == "wlan":
                    friendly_name = "Wireless Networks"
                elif subsystem_name == "wan":
                    friendly_name = "Internet Connection"
                elif subsystem_name == "lan":
                    friendly_name = "Local Network"
                elif subsystem_name == "vpn":
                    friendly_name = "VPN Services"
                else:
                    friendly_name = subsystem_name.replace("_", "/").title()
                
                summary += f"{icon} **{friendly_name}**: {status.title()}\n"
                if num_ok > 0:
                    summary += f"  ‚Ä¢ Online: {num_ok}\n"
                if num_pending > 0:
                    summary += f"  ‚Ä¢ Pending: {num_pending}\n"
                if num_disconnected > 0:
                    summary += f"  ‚Ä¢ Disconnected: {num_disconnected}\n"
                summary += "\n"
            
            return format_generic_list(health, "Site Health Status", ["subsystem", "status"])
            
        except Exception as e:
            logger.error(f"Error in site health resource for {site_name}: {e}")
            return f"Error retrieving health status for site {site_name}: {str(e)}"
    
    
    @mcp.resource("unifi://stats/dpi")
    async def resource_dpi_stats():
        """Get DPI statistics with clean formatting (default site)."""
        try:
            dpi_stats = await client.get_dpi_stats("default")
            
            if isinstance(dpi_stats, dict) and "error" in dpi_stats:
                return f"Error retrieving DPI stats: {dpi_stats['error']}"
            
            if not isinstance(dpi_stats, list):
                return "Error: Unexpected response format"
            
            if not dpi_stats:
                return "**UniFi DPI Statistics**\n\nNo DPI data available."
            
            # Sort by total bytes (tx + rx) and limit to top 10
            sorted_stats = sorted(dpi_stats, 
                                key=lambda x: (x.get('tx_bytes', 0) + x.get('rx_bytes', 0)), 
                                reverse=True)[:10]
            
            summary = f"**UniFi DPI Statistics** (Top {len(sorted_stats)} applications)\n\n"
            
            for stat in sorted_stats:
                app_name = stat.get("app", stat.get("cat", "Unknown Application"))
                tx_bytes = stat.get('tx_bytes', 0)
                rx_bytes = stat.get('rx_bytes', 0)
                total_bytes = tx_bytes + rx_bytes
                last_seen = format_timestamp(stat.get("time", 0))
                
                # Format bytes for display
                formatted_stat = format_data_values({"total": total_bytes, "tx": tx_bytes, "rx": rx_bytes})
                
                # Determine app icon based on name
                app_lower = app_name.lower()
                if "web" in app_lower or "http" in app_lower:
                    icon = "üåê"
                elif "video" in app_lower or "youtube" in app_lower or "netflix" in app_lower:
                    icon = "üìπ"
                elif "social" in app_lower or "facebook" in app_lower or "twitter" in app_lower:
                    icon = "üì±"
                elif "game" in app_lower or "gaming" in app_lower:
                    icon = "üéÆ"
                elif "mail" in app_lower or "email" in app_lower:
                    icon = "üìß"
                elif "file" in app_lower or "transfer" in app_lower:
                    icon = "üìÅ"
                else:
                    icon = "üìä"
                
                summary += f"{icon} **{app_name}**\n"
                summary += f"  ‚Ä¢ Total Data: {formatted_stat.get('total', '0 B')}\n"
                summary += f"  ‚Ä¢ Upload: {formatted_stat.get('tx', '0 B')} / Download: {formatted_stat.get('rx', '0 B')}\n"
                if last_seen != "Unknown":
                    summary += f"  ‚Ä¢ Last Seen: {last_seen}\n"
                summary += "\n"
            
            return format_generic_list(dpi_stats[:10], "DPI Statistics", ["app", "tx_bytes", "rx_bytes"])
            
        except Exception as e:
            logger.error(f"Error in DPI stats resource: {e}")
            return f"Error retrieving DPI stats: {str(e)}"
    
    
    @mcp.resource("unifi://stats/dpi/{site_name}")
    async def resource_site_dpi_stats(site_name: str):
        """Get DPI statistics with clean formatting for specific site."""
        try:
            dpi_stats = await client.get_dpi_stats(site_name)
            
            if isinstance(dpi_stats, dict) and "error" in dpi_stats:
                return f"Error retrieving DPI stats for site {site_name}: {dpi_stats['error']}"
            
            if not isinstance(dpi_stats, list):
                return "Error: Unexpected response format"
            
            if not dpi_stats:
                return f"**UniFi DPI Statistics - {site_name}**\n\nNo DPI data available."
            
            # Sort by total bytes (tx + rx) and limit to top 10
            sorted_stats = sorted(dpi_stats, 
                                key=lambda x: (x.get('tx_bytes', 0) + x.get('rx_bytes', 0)), 
                                reverse=True)[:10]
            
            summary = f"**UniFi DPI Statistics - {site_name}** (Top {len(sorted_stats)} applications)\n\n"
            
            for stat in sorted_stats:
                app_name = stat.get("app", stat.get("cat", "Unknown Application"))
                tx_bytes = stat.get('tx_bytes', 0)
                rx_bytes = stat.get('rx_bytes', 0)
                total_bytes = tx_bytes + rx_bytes
                last_seen = format_timestamp(stat.get("time", 0))
                
                # Format bytes for display
                formatted_stat = format_data_values({"total": total_bytes, "tx": tx_bytes, "rx": rx_bytes})
                
                # Determine app icon based on name
                app_lower = app_name.lower()
                if "web" in app_lower or "http" in app_lower:
                    icon = "üåê"
                elif "video" in app_lower or "youtube" in app_lower or "netflix" in app_lower:
                    icon = "üìπ"
                elif "social" in app_lower or "facebook" in app_lower or "twitter" in app_lower:
                    icon = "üì±"
                elif "game" in app_lower or "gaming" in app_lower:
                    icon = "üéÆ"
                elif "mail" in app_lower or "email" in app_lower:
                    icon = "üìß"
                elif "file" in app_lower or "transfer" in app_lower:
                    icon = "üìÅ"
                else:
                    icon = "üìä"
                
                summary += f"{icon} **{app_name}**\n"
                summary += f"  ‚Ä¢ Total Data: {formatted_stat.get('total', '0 B')}\n"
                summary += f"  ‚Ä¢ Upload: {formatted_stat.get('tx', '0 B')} / Download: {formatted_stat.get('rx', '0 B')}\n"
                if last_seen != "Unknown":
                    summary += f"  ‚Ä¢ Last Seen: {last_seen}\n"
                summary += "\n"
            
            return format_generic_list(dpi_stats[:10], "Site DPI Statistics", ["app", "tx_bytes", "rx_bytes"])
            
        except Exception as e:
            logger.error(f"Error in site DPI stats resource for {site_name}: {e}")
            return f"Error retrieving DPI stats for site {site_name}: {str(e)}"
    
    
    @mcp.resource("unifi://rogue-aps")
    async def resource_rogue_aps():
        """Get detected rogue access points with clean formatting (default site)."""
        try:
            rogue_aps = await client.get_rogue_aps("default")
            
            if isinstance(rogue_aps, dict) and "error" in rogue_aps:
                return f"Error retrieving rogue APs: {rogue_aps['error']}"
            
            if not isinstance(rogue_aps, list):
                return "Error: Unexpected response format"
            
            if not rogue_aps:
                return "**UniFi Rogue Access Points**\n\nüòä No rogue access points detected - network is secure!"
            
            summary = f"**UniFi Rogue Access Points** ({len(rogue_aps)} detected)\n\n"
            
            # Limit to 10 most recent detections
            for rogue in rogue_aps[:10]:
                ssid = rogue.get("essid", "[Hidden Network]")
                bssid = rogue.get("bssid", "Unknown")
                channel = rogue.get("channel", "Unknown")
                rssi = rogue.get("rssi", "Unknown")
                security = rogue.get("security", "Unknown")
                first_seen = format_timestamp(rogue.get("first_seen", 0))
                last_seen = format_timestamp(rogue.get("last_seen", 0))
                detected_by = rogue.get("ap_mac", "Unknown")
                
                # Determine security icon
                if security.lower() in ["wpa2", "wpa3", "wpa"]:
                    sec_icon = "üîí"
                elif security.lower() == "open":
                    sec_icon = "üîì"
                else:
                    sec_icon = "‚ùì"
                
                # Determine signal strength icon
                if isinstance(rssi, (int, float)):
                    if rssi > -50:
                        signal_icon = "üì¶"
                    elif rssi > -70:
                        signal_icon = "üì•"
                    else:
                        signal_icon = "üì§"
                else:
                    signal_icon = "‚ùì"
                
                summary += f"üö® **{ssid}** {sec_icon}\n"
                summary += f"  ‚Ä¢ BSSID: {bssid}\n"
                summary += f"  ‚Ä¢ Channel: {channel}\n"
                summary += f"  ‚Ä¢ Signal: {signal_icon} {rssi} dBm\n"
                summary += f"  ‚Ä¢ Security: {security}\n"
                summary += f"  ‚Ä¢ First Seen: {first_seen}\n"
                summary += f"  ‚Ä¢ Last Seen: {last_seen}\n"
                summary += f"  ‚Ä¢ Detected By: {detected_by}\n\n"
            
            if len(rogue_aps) > 10:
                summary += f"... and {len(rogue_aps) - 10} more rogue APs\n"
            
            return format_generic_list(rogue_aps[:10], "Rogue Access Points", ["ssid", "bssid", "channel", "rssi"])
            
        except Exception as e:
            logger.error(f"Error in rogue APs resource: {e}")
            return f"Error retrieving rogue APs: {str(e)}"
    
    
    @mcp.resource("unifi://rogue-aps/{site_name}")
    async def resource_site_rogue_aps(site_name: str):
        """Get detected rogue access points with clean formatting for specific site."""
        try:
            rogue_aps = await client.get_rogue_aps(site_name)
            
            if isinstance(rogue_aps, dict) and "error" in rogue_aps:
                return f"Error retrieving rogue APs for site {site_name}: {rogue_aps['error']}"
            
            if not isinstance(rogue_aps, list):
                return "Error: Unexpected response format"
            
            if not rogue_aps:
                return f"**UniFi Rogue Access Points - {site_name}**\n\nüòä No rogue access points detected - network is secure!"
            
            summary = f"**UniFi Rogue Access Points - {site_name}** ({len(rogue_aps)} detected)\n\n"
            
            # Limit to 10 most recent detections
            for rogue in rogue_aps[:10]:
                ssid = rogue.get("essid", "[Hidden Network]")
                bssid = rogue.get("bssid", "Unknown")
                channel = rogue.get("channel", "Unknown")
                rssi = rogue.get("rssi", "Unknown")
                security = rogue.get("security", "Unknown")
                first_seen = format_timestamp(rogue.get("first_seen", 0))
                last_seen = format_timestamp(rogue.get("last_seen", 0))
                detected_by = rogue.get("ap_mac", "Unknown")
                
                # Determine security icon
                if security.lower() in ["wpa2", "wpa3", "wpa"]:
                    sec_icon = "üîí"
                elif security.lower() == "open":
                    sec_icon = "üîì"
                else:
                    sec_icon = "‚ùì"
                
                # Determine signal strength icon
                if isinstance(rssi, (int, float)):
                    if rssi > -50:
                        signal_icon = "üì¶"
                    elif rssi > -70:
                        signal_icon = "üì•"
                    else:
                        signal_icon = "üì§"
                else:
                    signal_icon = "‚ùì"
                
                summary += f"üö® **{ssid}** {sec_icon}\n"
                summary += f"  ‚Ä¢ BSSID: {bssid}\n"
                summary += f"  ‚Ä¢ Channel: {channel}\n"
                summary += f"  ‚Ä¢ Signal: {signal_icon} {rssi} dBm\n"
                summary += f"  ‚Ä¢ Security: {security}\n"
                summary += f"  ‚Ä¢ First Seen: {first_seen}\n"
                summary += f"  ‚Ä¢ Last Seen: {last_seen}\n"
                summary += f"  ‚Ä¢ Detected By: {detected_by}\n\n"
            
            if len(rogue_aps) > 10:
                summary += f"... and {len(rogue_aps) - 10} more rogue APs\n"
            
            return format_generic_list(rogue_aps[:10], "Site Rogue Access Points", ["ssid", "bssid", "channel", "rssi"])
            
        except Exception as e:
            logger.error(f"Error in site rogue APs resource for {site_name}: {e}")
            return f"Error retrieving rogue APs for site {site_name}: {str(e)}"
    
    
    @mcp.resource("unifi://sysinfo")
    async def resource_sysinfo():
        """Get controller system information with clean formatting."""
        try:
            sysinfo = await client._make_request("GET", "/stat/sysinfo", site_name="default")
            
            if isinstance(sysinfo, dict) and "error" in sysinfo:
                return f"Error retrieving system info: {sysinfo['error']}"
            
            if not isinstance(sysinfo, dict):
                return "Error: Unexpected response format"
            
            summary = "**UniFi Controller System Information**\n\n"
            
            # Basic system info
            hostname = sysinfo.get("hostname", "Unknown")
            version = sysinfo.get("version", "Unknown")
            uptime = sysinfo.get("uptime", 0)
            timezone = sysinfo.get("timezone", "Unknown")
            
            # Format uptime
            if isinstance(uptime, (int, float)):
                days = int(uptime // 86400)
                hours = int((uptime % 86400) // 3600)
                uptime_str = f"{days} days, {hours} hours"
            else:
                uptime_str = "Unknown"
            
            summary += "üñ•Ô∏è **Controller Information**\n"
            summary += f"  ‚Ä¢ Hostname: {hostname}\n"
            summary += f"  ‚Ä¢ Version: {version}\n"
            summary += f"  ‚Ä¢ Uptime: {uptime_str}\n"
            summary += f"  ‚Ä¢ Timezone: {timezone}\n\n"
            
            # Memory info if available
            if "mem_total" in sysinfo or "mem_used" in sysinfo:
                mem_total = sysinfo.get("mem_total", 0)
                mem_used = sysinfo.get("mem_used", 0)
                if mem_total > 0:
                    mem_percent = (mem_used / mem_total) * 100
                    mem_free = mem_total - mem_used
                    
                    # Format memory values
                    formatted_mem = format_data_values({
                        "total": mem_total * 1024,  # Convert KB to bytes
                        "used": mem_used * 1024,
                        "free": mem_free * 1024
                    })
                    
                    summary += "üíæ **Memory Usage**\n"
                    summary += f"  ‚Ä¢ Total: {formatted_mem.get('total', 'Unknown')}\n"
                    summary += f"  ‚Ä¢ Used: {formatted_mem.get('used', 'Unknown')} ({mem_percent:.1f}%)\n"
                    summary += f"  ‚Ä¢ Free: {formatted_mem.get('free', 'Unknown')}\n\n"
            
            # Load average if available
            loadavg = sysinfo.get("loadavg_1", None)
            if loadavg is not None:
                summary += "üìä **System Load**\n"
                summary += f"  ‚Ä¢ 1-minute average: {loadavg}\n"
                if "loadavg_5" in sysinfo:
                    summary += f"  ‚Ä¢ 5-minute average: {sysinfo['loadavg_5']}\n"
                if "loadavg_15" in sysinfo:
                    summary += f"  ‚Ä¢ 15-minute average: {sysinfo['loadavg_15']}\n"
                summary += "\n"
            
            # Additional info if available
            if "board_rev" in sysinfo:
                summary += "üîß **Hardware**\n"
                summary += f"  ‚Ä¢ Board Revision: {sysinfo['board_rev']}\n"
                if "cpu_cores" in sysinfo:
                    summary += f"  ‚Ä¢ CPU Cores: {sysinfo['cpu_cores']}\n"
                summary += "\n"
            
            return format_generic_list([sysinfo], "System Information", ["hostname", "version", "uptime"])
            
        except Exception as e:
            logger.error(f"Error in sysinfo resource: {e}")
            return f"Error retrieving system info: {str(e)}"
    
    
    @mcp.resource("unifi://admins")
    async def resource_admins():
        """Get administrator accounts with clean formatting."""
        try:
            admins = await client._make_request("GET", "/stat/admin", site_name="")
            
            if isinstance(admins, dict) and "error" in admins:
                return f"Error retrieving admin accounts: {admins['error']}"
            
            if not isinstance(admins, list):
                return "Error: Unexpected response format"
            
            if not admins:
                return "**UniFi Administrator Accounts**\n\nNo administrator accounts found."
            
            summary = f"**UniFi Administrator Accounts** ({len(admins)} total)\n\n"
            
            for admin in admins:
                name = admin.get("name", "Unknown")
                email = admin.get("email", "Unknown")
                role = admin.get("role", "Unknown")
                is_super = admin.get("is_super", False)
                requires_new_password = admin.get("requires_new_password", False)
                last_login_by = admin.get("last_login_by", "Unknown")
                last_login_time = format_timestamp(admin.get("last_login_time", 0))
                email_alerts = admin.get("email_alert_enabled", False)
                
                # Determine admin icon based on role
                if is_super:
                    icon = "üëë"
                elif role.lower() == "admin":
                    icon = "üë®‚Äçüíª"
                else:
                    icon = "üë§"
                
                summary += f"{icon} **{name}** ({role})\n"
                summary += f"  ‚Ä¢ Email: {email}\n"
                if is_super:
                    summary += "  ‚Ä¢ Super Admin: ‚úÖ Yes\n"
                if requires_new_password:
                    summary += "  ‚Ä¢ Password Reset Required: ‚ö†Ô∏è Yes\n"
                if last_login_time != "Unknown":
                    summary += f"  ‚Ä¢ Last Login: {last_login_time} ({last_login_by})\n"
                if email_alerts:
                    summary += "  ‚Ä¢ Email Alerts: ‚úÖ Enabled\n"
                else:
                    summary += "  ‚Ä¢ Email Alerts: ‚ùå Disabled\n"
                summary += "\n"
            
            return format_generic_list(admins, "Admin Accounts", ["name", "email", "role"])
            
        except Exception as e:
            logger.error(f"Error in admins resource: {e}")
            return f"Error retrieving admin accounts: {str(e)}"